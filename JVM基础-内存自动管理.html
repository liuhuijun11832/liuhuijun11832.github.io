<!-- build time:Sat Jan 11 2020 21:39:46 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script>!function(e,t,o,c,i,d,a){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,d=t.createElement(o),a=t.getElementsByTagName(o)[0],d.async=1,d.src=c,d.charset="utf-8",a.parentNode.insertBefore(d,a)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/37dd6385.js","daovoice"),daovoice("init",{app_id:"37dd6385"}),daovoice("update")</script><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0"><link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222"><script>!function(e,t,o,c,i,d,a){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,d=t.createElement(o),a=t.getElementsByTagName(o)[0],d.async=1,d.src=c,d.charset="utf-8",a.parentNode.insertBefore(d,a)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/37dd6385.js","daovoice"),daovoice("init",{app_id:"37dd6385"}),daovoice("update")</script><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"7.0.0",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"Z2W38WTNSC",apiKey:"7df7d53c7892e2ae907462c4158eca2d",indexName:"hexo-blog",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="简述阅读周志明先生著《深入理解Java虚拟机》所记笔记。主要讲述虚拟机运行时区域、内存分配算法、垃圾回收算法以及虚拟机工具等基础内容。"><meta name="keywords" content="JVM"><meta property="og:type" content="article"><meta property="og:title" content="JVM基础-内存自动管理"><meta property="og:url" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理.html"><meta property="og:site_name" content="guitar-coder"><meta property="og:description" content="简述阅读周志明先生著《深入理解Java虚拟机》所记笔记。主要讲述虚拟机运行时区域、内存分配算法、垃圾回收算法以及虚拟机工具等基础内容。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545784608924_2.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545784608976_3.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545790220814_2.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545790329358_4.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545900213277_4.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545900365767_5.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545901607593_6.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1546391463867_5.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545967242992_5.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545975843777_2.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545978971259_3.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545979759441_4.png"><meta property="og:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545986888195_5.png"><meta property="og:updated_time" content="2020-01-01T14:46:37.638Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM基础-内存自动管理"><meta name="twitter:description" content="简述阅读周志明先生著《深入理解Java虚拟机》所记笔记。主要讲述虚拟机运行时区域、内存分配算法、垃圾回收算法以及虚拟机工具等基础内容。"><meta name="twitter:image" content="http://blog.guitar-coder.cn/JVM基础-内存自动管理/1545784608924_2.png"><link rel="canonical" href="http://blog.guitar-coder.cn/JVM基础-内存自动管理.html"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>JVM基础-内存自动管理 | guitar-coder</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c91d856e0af2969135bf34fb87ae8d93";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">guitar-coder</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="menu-item-icon fa fa-fw fa-comments"></i><br>留言板</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.guitar-coder.cn/JVM基础-内存自动管理.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘会俊"><meta itemprop="description" content="热爱coding的指弹玩家"><meta itemprop="image" content="/images/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="guitar-coder"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">JVM基础-内存自动管理</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-01-30 16:45:19" itemprop="dateCreated datePublished" datetime="2019-01-30T16:45:19+08:00">2019-01-30</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-01-01 22:46:37" itemprop="dateModified" datetime="2020-01-01T22:46:37+08:00">2020-01-01</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数： <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">10k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">9 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>阅读周志明先生著《深入理解Java虚拟机》所记笔记。<br>主要讲述虚拟机运行时区域、内存分配算法、垃圾回收算法以及虚拟机工具等基础内容。<br><a id="more"></a></p><h1 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h1><h2 id="区域概述"><a href="#区域概述" class="headerlink" title="区域概述"></a>区域概述</h2><p>Java虚拟机管理的内存包括：</p><ul><li>方法区（Method Area）</li><li>堆（Heap）</li><li>虚拟机栈（VM Stack）</li><li>本地方法栈（Native Method Stack）</li><li>程序计数器（Program Counter Register）<br>前两项是线程共享的的数据区，后三项是线程隔离的数据区，黑色区域是运行时数据区。</li></ul><p><img src="/JVM基础-内存自动管理/1545784608924_2.png" alt></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。也被称为非堆（non-heap），HotSpot虚拟机将GC分代扩展方法区，所以方法区也叫做永久代（Permanent Generation），但是实际上只是HotSpot虚拟机像管理堆一样管理方法区内存。在JDK1.7中，字符串常量池也从原来的永久代移到了堆中，而到了JDK1.8更是去除了永久带，改为了元数据空间（MetaSpace，但是本质都是方法区的一种实现），比较少出现垃圾收集的情况，当方法区无法满足内存分配时会出现OOM。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>存放对象实例，几乎所有的对象实例都在这里分配内存。但是随着JIT编译器的发展和逃逸分析技术逐渐程数，栈上分配、标量替换优化技术会让“所有对象都分配在堆上”渐渐变得不是那么绝对。堆中又划分：<br>新生代，由Eden空间，From Surivor和To Survivor等组成；<br>老年代；<br>线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>线程私有的，和线程同生共死。描述了方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。<br>局部变量表所需内存再编译期就会完成分配，在方法运行期间不会改变，这个数据区可能会抛出oom或者StackOverFlowError。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>虚拟机栈执行的是class文件，是字节码。而本地方法栈对于所执行的对象没有强制规定语言和数据结构，是由虚拟机自己实现，对于HotSpot虚拟机来说，其做法是将本地方法栈和虚拟机栈放到一起管理，所以这个数据区可能会出现的异常同虚拟机栈。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>该数据区的作用，可以简单理解﻿记录了执行到的代码行号。分支、循环、跳转、线程恢复、异常处理等都需要程序计数器来完成，字节码指示器就是依靠程序计数器来选去下一条字节码指令。<br>如果线程执行的是字节码文件，那么程序计数器记录的就是虚拟机字节码执行地址；如果执行的是本地方法，那么它为空（Undefined），这是唯一一个在Java虚拟机规范中没有规定任何OOM情况的数据区域。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>曾经是方法区的一部分，存放编译器生成的各种字面量（基本类型、final类型变量、字符串）和符号引用，在类加载完后进入运行时常量池中存放，字符串常量池就是在运行时常量池之中，因为无论是类、接口还是方法中的字符串，总是在编译时就能确定的。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>JDK1.4引入了NIO（New Input/Output）类，提供了一种基于通道（channel）的和缓冲区（buffer）的I/O方式，它可以直接调用本地native方法分配堆外内存，然后通过在堆中建立一个DirectByteBuffer作为堆外内存的引用从而实现了直接操作堆外内存，也避免了在Java堆中和直接内存中来回复制。直接内存大小默认和堆大小相同，可以通过-XX:MaxDirectMomorySize参数指定，会出现OOM错误。</p><h2 id="HotSpot对象"><a href="#HotSpot对象" class="headerlink" title="HotSpot对象"></a>HotSpot对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>new指令的执行过程：首先去运行时常量池里检查是否存在该类的符号引用，并且是否已经被加载解析和初始化过，如果没有还要先执行相对应的类加载过程。如果验证通过以后，会为一个类在堆上分配内存，分配方式根据堆的规整情况的使用不同的方法。在使用带整理过程的（compact）回收的收集器，例如Serial、ParNew等收集器，使用的就是指针碰撞法（Bump the Pointer），分配内存就是将临界点指针往空闲方向挪动与对象大小相等的距离；而CMS收集器使用的是Mark-Sweep算法的收集器通常使用空闲列表法（Free List），列表中记录了可用内存块，分配时划出足够大的内存。<br>线程安全性保证：</p><ul><li>CAS（该指令是硬件级原子操作指令）+失败重试</li><li>使用上文介绍的TLAB，可以通过-XX:+/-UseTLAB来决定是否启用，如果采用这种方式，在分配空间时就可以初始化零值，保证对象的实例字段可以不赋初始值即可使用<br>如果使用CAS方式，接下来需要初始化零值（不包括对象头），此时一个对象已经产生，但是还需要执行<init>方法来真正赋值。</init></li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p><img src="/JVM基础-内存自动管理/1545784608976_3.png" alt><br>Mark Word里根据虚拟机位数的不同分为32bit和64bit的非固定结构数据，以便在有限的空间存储尽可能多的信息，它会根据对象复用存储空间，其中，锁标志位为2bit，不同值存储不同信息：</p><table><thead><tr><th>内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>哈希码、对象分代年龄</td><td>01</td><td>对象未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>重量级锁定</td></tr><tr><td>空</td><td>11</td><td>GC标记</td></tr><tr><td>偏向线程ID，偏向时间戳，对象分代年龄</td><td>01</td><td>可偏向</td></tr></tbody></table><p>类型指针：对象指向它的类元数据，但是查找对象的类元数据不一定经过对象本身。对于数组来说，对象头中还有一块用于记录数组长度的数据。</p><p>实例数据：受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义的顺序的影响。长度相同的数据类型会被分配到一起。</p><p>对齐：HotSpot虚拟机的自动内存管理系统要求对象起始地必须是8字节的整数倍，也就是说对象必须是8字节的整数倍，对象头正好是8字节的1倍或者2倍，所以对齐通过占位保证对象大小是8字节的整数倍。</p><h3 id="对象寻址"><a href="#对象寻址" class="headerlink" title="对象寻址"></a>对象寻址</h3><p>1.句柄池寻址方式</p><p><img src="/JVM基础-内存自动管理/1545790220814_2.png" alt></p><p>栈中的reference引用了句柄池的内存地址，而该内存地址又分别指向了对象类型数据和对象实例数据。当对象的地址发生变化时，只需要改变句柄池所存储的指向地址即可，句柄本身地址不用改变.</p><p>2.直接寻址</p><p><img src="/JVM基础-内存自动管理/1545790329358_4.png" alt><br>相对于句柄寻址少了一次实例数据指针定位的操作，效率高一些。HotSpot虚拟机是采用这种方案。</p><h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><p>引用计数法：对象中有一个计数器，每当有一个地方引用该对象时就会在计数器里加1，但是解决不了循环引用的问题。</p><p>可达性分析法：GC Roots做根节向下寻找，搜索过的路径称为引用链。如果一个对象没有任何的链路到达GC Roots，就判定该对象是可以回收的对象。Jvm里可作为GC Roots的对象有以下几种：</p><ul><li>虚拟机栈（栈帧中的局部变量表）</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中Native Method引用的对象</li></ul><p>引用类型：</p><ul><li>强引用（Strong Reference）：代码中使用Object obj = new Object一类的方法；</li><li>软引用（Soft Reference）：描述一些还有用但非必须的对象，内存不足时不会立即回收，而是会加入待回收列表，下一次再回收；</li><li>弱引用（Weak Referenct）：描述非必须的对象，只能存活到下一次回收之前；</li><li>虚引用：通过这个对象被收集器回收时收到一个系统通知。</li></ul><h2 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h2><p>方法区主要有废弃变量回收和无用类回收：<br>废弃变量回收与回收堆中的基本一致<br>无用类回收需要同时满足：堆中没有任何该类实例；加载该类的ClassLoader已经卸载；该类对象的java.lang.Class对象没有在任何地方被引用</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>标记-清除算法（mark-sweep）：首先标记所有需要回收的对象，然后统一回收。但是两个节点的效率都不高，而且很容易产生空间碎片；<br>复制算法（copying）：将空间分为容量相等的两块，回收只需将存活的复制到另一块上，分配时直接可以使用指针碰撞法来分配；<br>标记-整理算法（mark-compact）：标记所有需要回收的对象，然后让所有对象往一端移动，然后直接清理掉边界以外的内存。</p><h2 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h2><p>根据对象不同的生命周期使用不同的收集算法：<br>新生代对象生存周期短，每次收集都会有大量对象回收，只有少数对象存活，复制算法比较合适；<br>老年代对象生存周期长，就必须使用标记清除或者标记整理算法。</p><h2 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h2><p>枚举根节点（GC Roots Tracing）：</p><p>可以作为GC Roots的节点必须是在全局引用或者执行上下文中；同时执行可达性分析的前提是建立在一致性快照的前提下—-保证在进行可达性分析的情况下对象的引用情况不会发生变化（通常伴随着stop the world，即停止所有的Java线程的情况）；大多数虚拟机都采用的是准确式GC，所以无需检查所有变量和上下文。<br>HotSpot借助OopMap的数据结构，在编译时就能知道什么偏移量上是什么数据类型；同时在JIT编译过程中，也会在safe-point中记录寄存器和栈中哪些位置是引用。</p><p>安全点（safe-point）：</p><p>保证程序长时间运行（特征：指令序列复用，例如方法调用，循环跳转，异常跳转）的代码段中，选定安全点，在安全点执行GC时对象的引用关系不会发生变化。<br>抢先式中断（Preemptive Suspensuin）：GC发生时主动暂停所有线程；<br>主动式中断（Voluntary Suspension）：GC需要中断线线程时，修改某个标志位，线程主动轮询这个标识位，发现中断标志为真时会主动中断挂起。</p><p>安全区域（safe-region）：</p><p>安全点的扩大版，可以理解为该区域内的对象引用关系不会变化。线程执行待安全区域代码段时，会标记自己进入safe-region，GC时可以直接回收该线程的对象，如果线程要离开safe-region，首先会检查GC是否已经完成，如果完成了会继续执行，没执行完成则会等待知道GC完成。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>并行与并发：并行（Parallel）是指多个垃圾收集线程工作；并发（Concurrent）是指垃圾收集线程和用户线程同时工作，但是可能是交替执行。</p><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>新生代收集器，虚拟机client模式下默认的收集器，稳定高效，单线程，使用复制算法。</p><h3 id="Par-new"><a href="#Par-new" class="headerlink" title="Par new"></a>Par new</h3><p>新生代收集器，虚拟机server模式下默认的收集器，多线程（默认与CPU数量相同），Serial的多线程版。</p><h3 id="Parallel-Scavenger"><a href="#Parallel-Scavenger" class="headerlink" title="Parallel Scavenger"></a>Parallel Scavenger</h3><p>新生代收集器，多线程，吞吐量可控，自适应收集器。<br>吞吐量计算：用户代码执行时间/（用户代码执行时间+垃圾收集执行时间）<br>重要参数：<br><code>-XX:MaxGCPauseMillis：</code>停顿时长；<br><code>-XX:GCTimeRatio:</code>小于100的正整数，相当于GC时间占用户代码执行时间的倒数。例如99，则GC时间：用户代码执行时间=1:99，所以吞吐量为99/（1+99）=99%，默认也是99；<br><code>-XX:+UseAdaptiveSizePolicy:</code>开启自适应模式，能够自动根据系统运行情况收集性能监控信息，动态调整例如新生代大小（<code>-Xmn</code>）、<code>Eden</code>区域和<code>Survivor</code>区域比例（<code>-XX:SurvivorRatio</code>）、对象晋升老年代年龄（<code>-XX:PretenureSizeThreshold</code>）等的参数，只需要设置好最大堆内存（<code>-Xmx</code>），停顿时长或者吞吐量等目标即可。</p><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p>老年代收集器，Serial的老年版，使用标记整理（mark-compact ）算法。</p><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>JDK1.6出现，Parallel Scavenger的老年代版本，使用标记整理算法。<br>拓展：<br>关于Parallel系的垃圾收集器，在Parallel Old出现以前，实际上6.3小节中提到的Parallel Scavenger并不是指某一个收集器，而是一个完整的垃圾收集框架，由PSScavenger（新生代）+PSMark-Sweep（老年代）组成，此处虽然名称是叫标记-清除算法，实际上只是在Serial Old的基础上加了一个壳。直到Parallel Old的出现，才算一套完整的吞吐量优先收集器。<br><code>-XX:+UseParallelGC</code>实际上是PSScavenger+PSMak-Sweep<br><code>-XX:+UseParallelOldGC</code>才是PSScavenger+Parallel Old</p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>Concurrent Mark Sweep，老年代收集器，使用标记清除算法，以低停顿为目标。<br><img src="/JVM基础-内存自动管理/1545900213277_4.png" alt><br>初始标记只是标记GC Roots能直接关联的对象，并发标记会进行GC Roots Tracing，重新标记则是对用户并发执行的用户线程产生变动的对象进行记录。时间：并发标记&gt;重新标记&gt;初始标记<br>缺点：<br>CPU资源敏感，默认回收线程数=（CPU数+3）/4，当CPU数低于2时很不划算；<br>浮动垃圾，即并发清除时用户线程留下来的未被清除的对象，只能等下一次GC，如果用户线程产生的对象大小大于GC预留的空间，会报“Concurrent Mode Failure”；<br>空间碎片，由于使用标记清除算法，会导致大量空间碎片，虽然默认开启了碎片整理（<code>-XX:+UseCMSCompactAtFullCollection</code>），但是碎片整理是无法并发的，因此可能会延长停顿时间。<br>重要参数：<code>-XX:CMSFullGCsBeforeCompaction</code>：不压缩Full GC次数，超过该次数后会进行一次压缩Full GC，默认是0，每次都会压缩。</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>Garbage-First，整个堆的收集器，基于复制算法和标记整理算法，未来有可能取代CMS。<br><img src="/JVM基础-内存自动管理/1545900365767_5.png" alt><br>G1把整个堆分成大小相等Region，Region之间通过复制算法，整体通过标记-整理算法。每个Region都会有一个Remembered Set（下文简称R Set），在对Reference类型数据进行写操作时会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于两个不同的Region之间，如果是，通过CardTable把相关引用信息记录到被引用对象所属的Region的R Set中，进行内存回收时，在GC根节点的枚举范围中加入R Set即可保证不扫描整个堆也没有遗漏。<br>收集过程大体类似于CMS的过程，区别在于最终标记阶段，这一阶段G1会将对象变动记录记录在每个标记线程的R set logs中，最后再合并到R Set里。<br><code>-XX：+UseG1GC</code>：启用G1 GC。JDK7和JDK8要求必须显示申请启动G1 GC，JDK可能会设置G1 GC为默认GC选项，也有可能会退到早期的Parallel GC，这个也请关注吧，JDK9预计2017年正式发布；</p><p><code>-XX：G1NewSizePercent</code>：初始年轻代占整个Java Heap的大小，默认值为5%；</p><p><code>-XX：G1MaxNewSizePercent</code>：最大年轻代占整个Java Heap的大小，默认值为60%；</p><h1 id="GC日志浅析"><a href="#GC日志浅析" class="headerlink" title="GC日志浅析"></a>GC日志浅析</h1><pre><code>[GC(MetadataGCThreshold)[PSYoungGen:22881K-&gt;5109K(71680K
    )]26152K-&gt;9484K(159232K),0.0126338secs][Times:user=0
    .02sys=0.01,real=0.02secs]
[FullGC(MetadataGCThreshold)[PSYoungGen:5109K-&gt;0K(71680K
    )][ParOldGen:4375K-&gt;6098K(52736K)]9484K-&gt;6098K(124416K
    ),[Metaspace:20679K-&gt;20679K(1067008K)],0
    .0529407secs][Times:user=0.11sys=0.00,real=0.05secs]
</code></pre><p>以上信息是使用了-XX:+PrintGCDetails打印出的GC日志。IDEA里可以点击<br><img src="/JVM基础-内存自动管理/1545901607593_6.png" alt><br>Edit Configurations，在VM Options里输入参数即可。[GC或者[Full GC 表示停顿类型，[Full GC（system）表示是由System.gc()引发的垃圾收集，Metadata表示是由元数据引发的GC，Allocation Failure表示是有新生代不足引发的GC，紧随其后的PSYoungGen表示使用的Parallel Scavenger收集的新生代，新生代和老年代的名称是根据收集器名称确定的。每个代的方括号内部的例如“22881K-&gt;5109K(71680K)”表示：“GC前该内存已使用容量-&gt;GC后该内存使用容量（该区域总容量）”，而最外层的”26152K-&gt;9484K(159232K)”则是表示整个堆。”0.0126338 secs”表示的是手机该内存区域使用的时间，单位为秒（secs），后面中括号里跟的Times则是具体时间详情，和Linux的time命令输出一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束的墙钟时间（Wall Clock Time）。CPU时间和墙钟时间的区别是：墙钟时间包括各种I/O，等待线程阻塞时间，而CPU时间则不包括时间，但当系统由多CPU或者多核的话，多线程操作会叠加这些时间。<br>拓展：<br>如果是开启或者关闭某个虚拟机选项，使用-XX:+/-<options>，如果是赋值某个选项，使用-XX:</options><options>=。</options></p><h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><p>Minor GC：新生代GC，速度较快</p><p>Major/Full GC：发生在老年代的GC，经常会伴随至少一次的Minor GC，但并不绝对，比Minor GC慢</p><p>分配策略：<br><img src="/JVM基础-内存自动管理/1546391463867_5.png" alt></p><p>其中，跟大对象阀值有关的参数有：<code>-XX:PretenureSizeThreshold，</code>单位为byte，新生代会优先分配在Eden区，跟使用TLAB有关的是+XX:+/-UseTLAB，TLAB在Eden区域，默认情况下占10%<br>GC策略：<br><img src="/JVM基础-内存自动管理/1545967242992_5.png" alt><br>重要参数：<br><code>-XX:MaxTenuringThreshold=15</code>：对象晋升年龄，每一次Minor GC以后仍然存活在Survivor区域中的对象年龄会+1</p><p><code>-XX:HandlePromotionFailure=true</code>：是否允许担保分配失败<br>对象年龄并不是完全按照上面这个参数来的，它还有一个动态判定策略：如果在Survivor空间中相同年龄的对象大小之和大于Survivor空间的一般，也会晋升老年代。</p><h1 id="虚拟机工具"><a href="#虚拟机工具" class="headerlink" title="虚拟机工具"></a>虚拟机工具</h1><h2 id="JDK自带命令行工具"><a href="#JDK自带命令行工具" class="headerlink" title="JDK自带命令行工具"></a>JDK自带命令行工具</h2><p>JDK自带命令行工具只是jdk/lib/tools.jar的一层薄封装而已。</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>jps</td><td>JVM Process Status Tool显示当前系统所有进程</td></tr><tr><td>jstat</td><td>JVM Statistics Monitoring Tool 收集虚拟机各方面运行数据</td></tr><tr><td>jinfo</td><td>显示虚拟机配置信息</td></tr><tr><td>jmap</td><td>Memory Map for Java 生成虚拟机的内存转储快照（heapdump文件）</td></tr><tr><td>jhat</td><td>JVM heap dump Browers 建立一个HTTP/HTML服务器方便用户分析heapdump文件</td></tr><tr><td>jstack</td><td>Stack Trace for Java 显示虚拟机的线程快照</td></tr></tbody></table><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>JVM Process Status Tool</p><p>格式： jps [option]<hostid></hostid></p><p>作用：通过RMI协议查询开启了RMI服务的远程虚拟机进程状态。</p><p>常用options:</p><p>option 作用<br>-q 只输出LVMID，省略主类名称<br>-l 输出主类的全名，如果进程执行的是Jar包，输出该包路径<br>-m 输出虚拟机进程启动时传递给主类main()函数的参数<br>-v 输出虚拟机进程启动时JVM参数<br>hostid 为RMI注册表中注册的主机名</p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>JVM Statistics Monitoring Tool</p><p>格式：jstat [option vmid [interval[s|ms] [count]]]</p><p>作用：监视虚拟机各种运行状态信息<br>如果是本地虚拟机进程，那么vmid和lvmid是一致的，如果是远程虚拟机进程，那么vmid的格式为：[progocol:][//]lvmid[@hostname[:port]/servername]，interval 和count 分表代表查询间隔和次数，如果省略这两个参数代表只查询一次。<br>常用options：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-calss</td><td>监视类装载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td>-gc</td><td>监视Java堆状况各个区容量、已用空间、GC合计时间等信息</td></tr><tr><td>-gccapacity</td><td>基本同-gc，但是更关注各个区使用到的的最大、最小空间</td></tr><tr><td>-gcutil</td><td>基本同-gc，但是输出的是已使用的百分比</td></tr><tr><td>-gccause</td><td>-gcutil基本一样，但是会额外输出导致上一次GC产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代GC状况</td></tr><tr><td>-gcnewcapacity</td><td>新生代使用到的最大最小空间</td></tr><tr><td>-gcold</td><td>监视老年代GC状况</td></tr><tr><td>-gcoldcapacity</td><td>老年代使用到的最大最小空间</td></tr><tr><td>-compiler</td><td>输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td>-printcompilation</td><td>输出已经被JIT编译的方法</td></tr></tbody></table><p>示例以及解析：<br><img src="/JVM基础-内存自动管理/1545975843777_2.png" alt><br>s0表示Survivor的from区，s1表示to，E表示Eden区的已经使用量，O代表老年代，M代表MetaSpace，CCS表示压缩使用比例，YGC表示新生代回收次数，FGC表示Full GC次数，FGCT表示Full GC时间，GCT表示总的GC时间。</p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>Configuration Info for Java<br>格式：jinfo [option] pid<br>作用：实时地查看和戴哦整虚拟机各项参数。</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-sysprops</td><td>可以把System.getProperties()的内容打印出来</td></tr><tr><td>-flag</td><td>flag后面可以跟javm参数的key，这样就可以获得该key的值</td></tr></tbody></table><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>Memory Map for Java</p><p>格式：jmap [option] vmid</p><p>options列表：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-dump</td><td>生成Java堆转储快照，格式为-dump:[live,]format=b,file=<filename></filename></td></tr><tr><td>-finalizerinfo</td><td>显示在F-Queue中等Finalizer线程执行finalize方法的对象，只在Linux/Solaris下有效</td></tr><tr><td>-heap</td><td>显示Java堆详细信息，如回收器、参数配置、分代状况等，只在Linux/Solaris下有效</td></tr><tr><td>-histo</td><td>显示堆中对象统计信息，包括类、示例数量、合计容量</td></tr></tbody></table><p><img src="/JVM基础-内存自动管理/1545978971259_3.png" alt></p><p>Minor GC：新生代GC，速度较快<br>Major/Full GC：发生在老年代的GC，经常会伴随至少一次的Minor GC，但并不绝对，比Minor GC慢<br>分配策略：</p><p>其中，跟大对象阀值有关的参数有：<code>-XX:PretenureSizeThreshold</code>，单位为byte，新生代会优先分配在Eden区，跟使用TLAB有关的是<code>+XX:+/-UseTLAB</code>，TLAB在Eden区域，默认情况下占10%<br>GC策略：</p><p>重要参数：<br><code>-XX:MaxTenuringThreshold=15</code>：对象晋升年龄，每一次Minor GC以后仍然存活在Survivor区域中的对象年龄会+1<br><code>-XX:HandlePromotionFailure=true</code>：是否允许担保分配失败<br>对象年龄并不是完全按照上面这个参数来的，它还有一个动态判定策略：如果在Survivor空间中相同年龄的对象大小之和大于Survivor空间的一般，也会晋升老年代。</p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>JVM Heap Analysis Tool<br>格式：jhat<file><br>可以对dump出来的文件进行解析，并且会创建一个微型的HTTP/HTML服务器，可以在浏览器中查看页面，但是一般并不推荐这么做。</file></p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>Stack Trace for Java<br>格式:jstack [option] vmid<br>options:</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当正常使出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td>-l</td><td>出堆栈外，显示关于锁的附加信息</td></tr><tr><td>-m</td><td>如果调用到本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table><h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p>这个工具并不是命令行工具，而是一个可视化工具，所以必须在带交互界面的系统上执行，例如Windows和Mac，位于JDK/bin目录下，也可以在命令行中直接执行jconsole。<br>下图是在IDEA中打开某个项目的情况：<br><img src="/JVM基础-内存自动管理/1545979759441_4.png" alt></p><h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>多合一故障处理工具，可以在IDEA里或者Eclips里以插件形式启动。同时它还有一个插件BTrace，这个插件可以作为程序独立运行，作用是在不停止目标程序运行的前提下，通过HotSpot VM的HostSwap技术动态加入原本不存在的调试代码。<br><img src="/JVM基础-内存自动管理/1545986888195_5.png" alt><br>需要注意的是，如果要使用VisualVM连接远程的程序，需要在程序启动时加上以下VM参数：</p><pre><code>-Djava.rmi.server.hostname=localhost
-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=1099
-Dcom.sun.management.jmxremote.authenticate=false
-Dcom.sun.management.jmxremote.ssl=false
</code></pre><p>启用jmx并且不使用ssl和用户名密码校验，并且在Visual VM里添加jmx连接才能连接远程项目。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机：JVM高级特性和最佳实践》周志明 著<br><a href="https://hllvm-group.iteye.com/group/topic/37095" rel="external nofollow noopener noreferrer" target="_blank">https://hllvm-group.iteye.com/group/topic/37095</a></p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创、技术分享。请作者喝杯茶吧！</div><button id="rewardButton" disable="enable" onclick="var qr = document.getElementById(&quot;QR&quot;); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/wechatpay.png" alt="刘会俊 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.png" alt="刘会俊 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JVM/" rel="tag"># JVM</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/Java输出文字到图片.html" rel="next" title="Java输出文字到图片"><i class="fa fa-chevron-left"></i> Java输出文字到图片</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/hexo接入在线聊天daovoice.html" rel="prev" title="Hexo接入在线聊天daovoice">Hexo接入在线聊天daovoice <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="刘会俊"><p class="site-author-name" itemprop="name">刘会俊</p><p class="site-description motion-element" itemprop="description">热爱coding的指弹玩家</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/liuhuijun11832" title="GitHub &rarr; https://github.com/liuhuijun11832" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/qin-yuan-78-98/activities" title="知乎 &rarr; https://www.zhihu.com/people/qin-yuan-78-98/activities" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-globe"></i>知乎</a> </span><span class="links-of-author-item"><a href="http://www.guitar-coder.cn/img/Wechat.jpeg" title="微信 &rarr; http://www.guitar-coder.cn/img/Wechat.jpeg" rel="noopener" target="_blank"><i class="fa fa-fw fa-wechat"></i>微信</a> </span><span class="links-of-author-item"><a href="http://www.guitar-coder.cn/img/QQ.jpeg" title="qq &rarr; http://www.guitar-coder.cn/img/QQ.jpeg" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>qq</a> </span><span class="links-of-author-item"><a href="mailto:liuhuijun_2017@163.com" title="E-Mail &rarr; mailto:liuhuijun_2017@163.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.iocoder.cn/" title="http://www.iocoder.cn/" rel="external nofollow noopener noreferrer" target="_blank">芋道源码</a></li><li class="links-of-blogroll-item"><a href="http://blog.didispace.com/" title="http://blog.didispace.com/" rel="external nofollow noopener noreferrer" target="_blank">程序猿DD</a></li><li class="links-of-blogroll-item"><a href="https://blog.iooo.tech" title="https://blog.iooo.tech" rel="external nofollow noopener noreferrer" target="_blank">张砚池的博客</a></li><li class="links-of-blogroll-item"><a href="https://guanpengchn.github.io/" title="https://guanpengchn.github.io/" rel="external nofollow noopener noreferrer" target="_blank">牧码</a></li><li class="links-of-blogroll-item"><a href="https://suveng.github.io/blog" title="https://suveng.github.io/blog" rel="external nofollow noopener noreferrer" target="_blank">suveng`s blog</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简述"><span class="nav-number">1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自动内存管理机制"><span class="nav-number">2.</span> <span class="nav-text">自动内存管理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#区域概述"><span class="nav-number">2.1.</span> <span class="nav-text">区域概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区"><span class="nav-number">2.1.1.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆"><span class="nav-number">2.1.2.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟机栈"><span class="nav-number">2.1.3.</span> <span class="nav-text">虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地方法栈"><span class="nav-number">2.1.4.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器"><span class="nav-number">2.1.5.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量池"><span class="nav-number">2.1.6.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接内存"><span class="nav-number">2.1.7.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HotSpot对象"><span class="nav-number">2.2.</span> <span class="nav-text">HotSpot对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的创建"><span class="nav-number">2.2.1.</span> <span class="nav-text">对象的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">2.2.2.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象寻址"><span class="nav-number">2.2.3.</span> <span class="nav-text">对象寻址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾收集"><span class="nav-number">3.</span> <span class="nav-text">垃圾收集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象引用"><span class="nav-number">3.1.</span> <span class="nav-text">对象引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区回收"><span class="nav-number">3.2.</span> <span class="nav-text">方法区回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集算法"><span class="nav-number">3.3.</span> <span class="nav-text">垃圾收集算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分代思想"><span class="nav-number">3.4.</span> <span class="nav-text">分代思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HotSpot算法实现"><span class="nav-number">3.5.</span> <span class="nav-text">HotSpot算法实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">3.6.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial"><span class="nav-number">3.6.1.</span> <span class="nav-text">Serial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Par-new"><span class="nav-number">3.6.2.</span> <span class="nav-text">Par new</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scavenger"><span class="nav-number">3.6.3.</span> <span class="nav-text">Parallel Scavenger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-Old"><span class="nav-number">3.6.4.</span> <span class="nav-text">Serial Old</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Old"><span class="nav-number">3.6.5.</span> <span class="nav-text">Parallel Old</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS"><span class="nav-number">3.6.6.</span> <span class="nav-text">CMS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1"><span class="nav-number">3.6.7.</span> <span class="nav-text">G1</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GC日志浅析"><span class="nav-number">4.</span> <span class="nav-text">GC日志浅析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存分配与回收策略"><span class="nav-number">5.</span> <span class="nav-text">内存分配与回收策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机工具"><span class="nav-number">6.</span> <span class="nav-text">虚拟机工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK自带命令行工具"><span class="nav-number">6.1.</span> <span class="nav-text">JDK自带命令行工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jps"><span class="nav-number">6.1.1.</span> <span class="nav-text">jps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jstat"><span class="nav-number">6.1.2.</span> <span class="nav-text">jstat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jinfo"><span class="nav-number">6.1.3.</span> <span class="nav-text">jinfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jmap"><span class="nav-number">6.1.4.</span> <span class="nav-text">jmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jhat"><span class="nav-number">6.1.5.</span> <span class="nav-text">jhat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jstack"><span class="nav-number">6.1.6.</span> <span class="nav-text">jstack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jconsole"><span class="nav-number">6.1.7.</span> <span class="nav-text">jconsole</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VisualVM"><span class="nav-number">6.1.8.</span> <span class="nav-text">VisualVM</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">京ICP备19003464号 </a>&copy; 2018 – <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">刘会俊</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">479k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">7:16</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">NexT.Mist</a></div><span class="post-meta-divider">| </span><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>function createtime(){var n=new Date("01/31/2019 10:16:43");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest.min.js"></script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/src/utils.js?v=7.0.0"></script><script src="/js/src/motion.js?v=7.0.0"></script><script src="/js/src/schemes/muse.js?v=7.0.0"></script><script src="/js/src/scrollspy.js?v=7.0.0"></script><script src="/js/src/post-details.js?v=7.0.0"></script><script src="/js/src/bootstrap.js?v=7.0.0"></script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=7.0.0"></script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(e,t){var n=$("<div>").addClass("highlight-wrap");$(t).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(e){var t=$(this).parent().find(".code").find(".line").map(function(e,t){return $(t).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=document.createRange(),a=window.getSelection(),i=window.pageYOffset||document.documentElement.scrollTop;n.style.top=i+"px",n.style.position="absolute",n.style.opacity="0",n.value=t,n.textContent=t,n.contentEditable=!0,n.readOnly=!1,document.body.appendChild(n),o.selectNode(n),a.removeAllRanges(),a.addRange(o),n.setSelectionRange(0,t.length);var d=document.execCommand("copy");d?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(e){var t=$(this).find(".copy-btn");setTimeout(function(){t.text("复制")},300)}).append(t)})</script></body></html><!-- rebuild by neat -->