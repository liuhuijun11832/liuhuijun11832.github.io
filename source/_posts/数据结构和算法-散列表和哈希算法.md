---
title: 数据结构和算法-散列表和哈希算法
categories: 数据结构/算法
date: 2019-06-18 13:05:16
tags: 数据结构/算法
keywords: [散列表,哈希算法]
description: 散列表和哈希算法的原理和应用
---
# 简述
散列表：利用数组支持按下标访问数据的特性扩展出的一种数据结构；

哈希算法：将任意长度的二进制值串映射为固定长度的二进制值串的一种算法。

<!--more-->

# 散列表

散列思想：即哈希算法的思想原理；

散列函数：

1. 计算得出的散列值是一个非负整数；
2. 两个相等key得出的散列值必然相等；
3. 两个不相等key得出的散列值必然不相等。

实际上，第三个条件几乎没有任何算法能够满足。

散列冲突：两个不相等key得出同一个散列值。

散列冲突的解决方案：

- 开放寻址法：如果出现散列冲突，就重新探测新的位置，即从冲突的位置往后找一步步，找到空闲位置就插入，没找到则从头开始找（线性探测）；或者是往后1的平方，2的平方步找（二次探测）；又或者是对冲突的散列值再进行一次散列（二次散列）；不过不管用什么方法，如果散列表中空闲位置不多的话，散列冲突的概率还是很高，为了尽可能保证散列表的操作效率，一般情况下都会尽可能保证三列表中有一定比例的空闲槽位，用**装载因子**表示空位的多少，计算公式是：`load factor = 表中元素个数/散列表总长度`，装载因子越大，空位越少，散列表性能越低。
- 链表法：在冲突的槽位上有一个链表，冲突的即放到相同槽位的链表中，其删除和查找的时间复杂度都是O(n)，只和链表长度成正比。
Word文档的单词提示就可以借助散列表来实现：

常用的英文单词大概在20万个左右，假设单词平均长度为10个字母，平均一个单词占用10个字节的内存空间，那么20万个英文单词大概占用2MB空间，完全可以利用散列表的形式存储在内存中，当用户输入单词时，通过散列函数生成散列值然后去散列表中查找，能够找到即表示拼写可能正确；找不到即提示错误。

散列函数设计原则：
1. 不能太复杂，否则影响执行效率；
2. 散列值要随机，并且均匀分布。

散列表设计原则：
1. 合理的默认初始大小，比如Java中HashMap为16；
2. 合理的装载因子和扩容方案，比如HashMap的0.75和扩容为两倍；
3. 散列冲突解决方案，**采用线性探测的开放寻址法适合数据量小，装载因子小的时候，比如ThreadLocalMap；采用链表法适合存储大对象，大数据量的散列表，并且有更多的优化策略，比如JDK8的HashMap中链表长度大于8时，链表转换为红黑树，小于8时变成链表**。



