---
title: 设计模式-开篇记
categories: 设计模式
date: 2019-03-22 16:20:50
tags: 设计模式
keywords: [设计模式]
description: 设计模式开篇词，记录了部分《设计模式之禅》的笔记
---

# 前言

之所以开了一个写设计模式的系列，是因为在上家公司之时曾经用过其中的几种，而今将近半年时间过去，由于当初理解的不深入，导致现在已经忘了很多。技能这个东西总是越练越熟的，在我的理解中，语言是交流的工具，例如Java，C等各种计算机语言是我们与计算机交流的一种工具；算法是交流的逻辑和套路；数据结构是语言的组织方式；网络是远程的联系方式。如果把我们写的一个项目当成是一个人对计算机发表的演讲，那么设计模式就是演讲里的奇技淫巧，使我们的项目结构更清晰，扩展更加容易，人与机器皆大欢喜。

<!--more-->

# UML类图

由于笔记中会有一些类图，所以这里记载一下类图之间的关系。图片来源于[https://www.cnblogs.com/pangjianxin/p/7877868.html](https://www.cnblogs.com/pangjianxin/p/7877868.html)

（原图出处我也不知道，如有侵权请联系我删除）

![Class Diagram](设计模式-开篇记\Class Diagram.png)

各种不同组件之间的关系如上图，其中组合和聚合容易混淆：组合的关系比较强，例如翅膀是鸟不可分割的一部分，翅膀离开鸟就毫无意义；聚合的关系稍微弱一些，例如大雁在一起成了雁群，但是脱离雁群依然有自己的生命。关联和依赖同样如此，不同气候下人的肤色不一样；但人都需要大气和水，所以人气候是关联关系，但是人依赖大气和水。

# 设计原则

## 总纲：开闭原则

开闭原则是接下来说的几种设计原则的总纲，它的定义为：Software entities like classes,modules and functions shoud be open for extension but closed for modifications.

简单来说，就是“对修改关闭，对扩展开放”。

举个例子：

    我们原来的交易系统总共有三种订单类型：商城订单，代金券订单，商户买单订单。三种业务对应的业务类型编码是不一样的，按照普通的方式来写，我们是这种方式：

```java
if("mallOrder".equals(type)){
    businessService.doMallBusiness();
}else if("voucherOrder".equals(type)){
    businessService.doVoucherBusiness();
}else{
    //......
}
```

现在如果商城的商品出现打折，通常的做法就是修改doMallBusiness()里面的方法，结算时加入折扣的计算，这种做法的问题在于：所有功能已经通过测试的稳定代码会变得不稳定，乃至重新测试，而通常来说，我们一个类都只有一个测试类，每个类里的测试方法至少有三种：业务逻辑测试、边界测试、异常测试。对于业务复杂的方法可能测试会更多，如果修改了原有代码，需要改的测试方法同样会有很多，甚至会有遗漏的，结果严重会影响到线上程序崩溃。

开闭原则的优点：

1. 提高模块复用性，模块粒度越小越容易被复用；

2. 提高可维护性，使用扩展代替修改；

3. 面向对象开发的需求。

## 单一职责原则

Single Responsibility Principle，简称SPR。

> There should never be more than one reason for a class to change.

这里将引起变化的原因代替职责作为衡量一个接口或者类设计的是否优秀的标准，我对此的理解是，如果一个接口或者类修改，只对其实现类或者子类有影响，那么就说这个接口或者类就是符合单一职责原则的。但是现实项目中最难划分的就是类的职责，需要根据项目和环境来区别对待。**我们不能因为用设计原则而用，而需要根据业务场景类设计，也不需要一味死守设计模式而不知变通，最推荐的就是接口的设计做到单一职责，类的设计尽量做到只有一个原因引起变化。**

## 里氏替换原则

> if for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substited for o2 then S is a subtype of T.

如果每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么说S为T的子类型。
