---
title: 数据结构和算法-递归和排序
categories: 编程技术
date: 2019-06-02 17:48:42
tags: 数据结构/算法
keywords: [递归,排序]
description: 递归和排序学习笔记
---

# 简述

Recursion，递归是一种非常广泛的算法，很多数据结构和算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等。

Sort，排序算法是每个人都要掌握的算法，分析排序算法同样也能够锻炼对大O表示法的掌握。

<!--more-->

# 递归

## 递归条件

递归需要满足的三个条件：

- 一个问题可以分解为几个子问题的解；

- 问题和子问题之间，除了数据规模，解题思路是一样；

- 存在递归终止条件。

**递归代码的关键在于如何找到将大问题分解为小问题的规律，并且基于此写出递归公式，然后推敲终止条件，最后将递推公式和终止条件翻译成代码，例如`f(n)=f(n-1)+f(n-2)`。**

## 递归问题

警惕堆栈溢出和重复计算。

堆栈溢出：



计算中的函数调用会使用临时变量所封装的栈帧压入栈，系统栈或者虚拟机栈空间一般都不大，如果递归的数据规模很大，很容易堆栈溢出，**解决办法是，最好设置一个最大的调用深度。**



重复计算：



例如计算f(5)，可以分解为f(4)+f(3)，也就是分解为f(3)+f(2)+f(3)，此时f(3)就计算了两次，**解决办法是，利用散列表或者某种其他的数据结构保存已经计算的结果。**



还有空间复杂度可能会较高的问题。

# 排序

种类：

| 排序算法     | 时间复杂度 | 是否基于比较 |
| -------- | ----- | ------ |
| 冒泡、插入、选择 | O(n²) | √      |
| 快排、归并    |    O(nlogn)   | √      |
| 桶、计数、基数  |     O(n)  | ×      |

分析方法：

1. 最好情况、最坏情况、平均情况时间复杂度，因为有序度不同的数据对排序会有一定影响;
2. 时间复杂度的系数、常数、低阶，由于常用的排序数据可能不多，所以要考虑这些因素;
3. 比较次数和交换次数;
4. 内存消耗，**原地排序就是指空间复杂度为O(1)的排序算法**;
5. 稳定性，如果待排序的数据中存在相等的数据，这两个相等数据没有发生前后顺序的变化，则称该算法为稳定排序；
6. 有序度：数组中具有有序关系的元素对的个数，满有序度就是所有元素有序，其值为：n*(n-1)/2，逆序度=满有序度-有序度。

## 冒泡排序（Bubble Sort）
原理：前后两个元素两两比较，根据结果排序。

例如：

	[4,5,6,3,2,1]
	满有序度：6*5/2=15
	有序度：3
	逆有序度：12（需要交换12次）
	第一次冒泡：[4,5,3,2,1,6]交换3次
	第二次冒泡：[4,3,2,1,5,6]交换3次
	第三次冒泡：[3,2,1,4,5,6]交换3次
	第四次冒泡：[2,1,3,4,5,6]交换2次
	第五次冒泡：[1,2,3,4,5,6]交换1次
	第六次冒泡：[1,2,3,4,5,6]交换0次
特征：原地排序、稳定排序
时间复杂度：
- 最好：O(n);
- 最坏：O(n²);
- 平均：最好的情况下，有序度就是n(n-1)/2，所以平均可以取中间值O(n(n-1)/4)，即为O(n²)，这是种好用但是不严格的分析方法。

## 插入排序（Insertion Sort）
原理：将待排序数据分为两个区间，已排序区和未排序区，然后分别取未排序区数据放入到已排序区。

例如：

	[4,5,6,1,3,2]
	满有序度：15
	有序度：5
	逆有序度：10（需要交换10次）
	4作为已排序区，剩下的作为未排序区
	第一次插入：5>4，位置不变
	第二次插入：6>4，位置不变
	第三次插入：1<4，将1往前移3位到第一位[1,4,5,6,3,2]
	第四次插入：1<3<4，将3往前移3位到第二位[1,3,4,5,6,2]
	第五次插入：1<2<3，将2往前移4位到第二位[1,2,3,4,5,6]
	
特征：原地排序、稳定排序
时间复杂度：
- 最好：O(n)
- 最差：O(n²)
- 平均：O(n²)

## 选择排序（Selection Sort）
原理：将待排序数据分为两个区间，已排序区和未排序区，每次从未排序区找到最小的元素，将其放到已排序区的末尾。

例如：
	
	[4,5,6,3,2,1]

	第一次选择：1和4交换[1,5,6,3,2,4]
	第二次选择：2和5交换[1,2,6,3,5,4]
	第三次选择：6和3交换[1,2,3,6,5,4]
	第四次选择：6和4交换[1,2,3,4,6,5]
	第五次选择：6和5交换[1,2,3,4,5,6]
特征：原地排序、非稳定排序（因为交换可能导致前面的数被交换到最后一位）
- 最好：O(n²)
- 最差：O(n²)
- 平均：O(n²)

	