<!-- build time:Sun Jan 12 2020 22:39:43 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script>!function(e,t,o,c,i,d,a){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,d=t.createElement(o),a=t.getElementsByTagName(o)[0],d.async=1,d.src=c,d.charset="utf-8",a.parentNode.insertBefore(d,a)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/37dd6385.js","daovoice"),daovoice("init",{app_id:"37dd6385"}),daovoice("update")</script><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0"><link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222"><script>!function(e,t,o,c,i,d,a){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,d=t.createElement(o),a=t.getElementsByTagName(o)[0],d.async=1,d.src=c,d.charset="utf-8",a.parentNode.insertBefore(d,a)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/37dd6385.js","daovoice"),daovoice("init",{app_id:"37dd6385"}),daovoice("update")</script><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"7.0.0",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"Z2W38WTNSC",apiKey:"7df7d53c7892e2ae907462c4158eca2d",indexName:"hexo-blog",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="spring mvc源码学习笔记"><meta name="keywords" content="Spring mvc"><meta property="og:type" content="article"><meta property="og:title" content="Spring MVC源码初探(一)-容器初始化"><meta property="og:url" content="http://blog.guitar-coder.cn/Spring-MVC源码初探.html"><meta property="og:site_name" content="guitar-coder"><meta property="og:description" content="spring mvc源码学习笔记"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://blog.guitar-coder.cn/Spring-MVC源码初探/DispatcherServlet-Class-Diagram.png"><meta property="og:image" content="http://blog.guitar-coder.cn/Spring-MVC源码初探/ApplicationContextEvent-and-Implementions.png"><meta property="og:image" content="http://blog.guitar-coder.cn/Spring-MVC源码初探/SourceFilteringListener-Extends-Structure.png"><meta property="og:image" content="http://blog.guitar-coder.cn/Spring-MVC源码初探/Spring-MVC-Request-Flow.jpg"><meta property="og:updated_time" content="2020-01-01T14:46:37.715Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring MVC源码初探(一)-容器初始化"><meta name="twitter:description" content="spring mvc源码学习笔记"><meta name="twitter:image" content="http://blog.guitar-coder.cn/Spring-MVC源码初探/DispatcherServlet-Class-Diagram.png"><link rel="canonical" href="http://blog.guitar-coder.cn/Spring-MVC源码初探.html"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>Spring MVC源码初探(一)-容器初始化 | guitar-coder</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c91d856e0af2969135bf34fb87ae8d93";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">guitar-coder</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="menu-item-icon fa fa-fw fa-comments"></i><br>留言板</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.guitar-coder.cn/Spring-MVC源码初探.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘会俊"><meta itemprop="description" content="热爱coding的指弹玩家"><meta itemprop="image" content="/images/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="guitar-coder"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Spring MVC源码初探(一)-容器初始化</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-04 15:42:01" itemprop="dateCreated datePublished" datetime="2019-10-04T15:42:01+08:00">2019-10-04</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-01-01 22:46:37" itemprop="dateModified" datetime="2020-01-01T22:46:37+08:00">2020-01-01</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数： <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">13k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">12 分钟</span></div><div class="post-description">spring mvc源码学习笔记</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>Git</li><li>Gradle</li><li>IDEA 2018以上版本</li><li>JDK 1.8+</li></ul><p>从<a href="https://github.com/spring-projects/spring-framework" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/spring-projects/spring-framework</a>fork出一份源代码到自己的仓库，方便自己能写注释，以及运行test等。</p><p>当前使用的是Spring 5.1.3.BUILD-SNAPSHOT的版本</p><p>spring框架里的web模块包括webmvc、websocket、webflux，其中，web模块是另外三个模块的父模块。</p><p>代码拉下来以后，执行<code>./gradlew :spring-oxm:compileTestJava</code>出现success即为成功。</p><a id="more"></a><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>在Spring MVC初始化时，总共涉及到两个容器，一个是Root WebApplicationContext，还有一个是Servlet WebApplicationContext。</p><p>看一下常用的web.xml的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省略非关键的配置 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- [1] Spring配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定Spring Bean的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ====================================== --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- [2] Spring MVC配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以自定义servlet.xml配置文件的位置和名称，默认为WEB-INF目录下，名称为[&lt;servlet-name&gt;]-servlet.xml，如spring-servlet.xml</span></span><br><span class="line"><span class="comment">    &lt;init-param&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-value&gt;/WEB-INF/spring-servlet.xml&lt;/param-value&gt; // 默认</span></span><br><span class="line"><span class="comment">    &lt;/init-param&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Root-WebApplication"><a href="#Root-WebApplication" class="headerlink" title="Root WebApplication"></a>Root WebApplication</h2><p>首先进入的就是<code>ContextLoaderListener#contextInitialized</code>方法，这个监听实现了<code>ServletContextListener</code>，是一个servlet与容器进行通信的接口，所以如果在web.xml中配置了<code>&lt;Listener&gt;</code>标签以后，容器启动时就会启动该监听，并执行<code>contextInitialized</code>方法，这个方法继承自<code>contextLoader</code>，所以直接会调用<code>ContextLoader#initWebApplicationContext</code>方法，顾名思义，这个方法就是用来初始化Root wac(Web Application Context简称)。</p><p>这里主要是调用了<code>createWebApplicationContext</code>创建容器，和<code>configureAndRefreshWebApplicationContext</code>配置和刷新容器。</p><p>创建wac：<code>createWebApplicationContext</code>—&gt;<code>determineContextClass</code>，这个方法决定了要使用什么类型的wac，默认情况下，<code>defaultStrategies</code>就是读取了<code>ContextLoader.properties</code>的Properties，它指定了默认的wac类型是<code>XmlWebApplicationContext</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">  	<span class="comment">//获取sc里的初始化参数</span></span><br><span class="line">		String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line">		<span class="keyword">if</span> (contextClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">						<span class="string">"Failed to load custom context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//默认策略，这里会使用Class.forName()反射创建类类型并返回</span></span><br><span class="line">			contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">						<span class="string">"Failed to load default context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>返回一个类类型以后，在<code>createWebApplicationContext</code>方法中，通过反射技术会创建该类类型的一个实例对象出来。接着会设置父容器，配置和刷新当前容器，但是在刚创建容器的时候，由于并没有显示指定容器中active这个AtomicBoolean的值，所以默认为false，这时候会进入设置父容器和配置wac的步骤。</p><p>如果wac的父容器为空，会设置wac的父容器。当前这个已经是Root wac了，所以其实<code>loadParentContext</code>这个方法返回为空，并且没有任何一个子类去重写，<strong>由此得知，Root wac的父容器通常始终为空</strong>。</p><p>接下来会将wac放到<code>ServletContext</code>(以下简称sc)的attribute里，由对应的Web容器放到自己的容器上下文里，在Tomcat里就是<code>ApplicationContext</code>，该类里保存了一个<code>ConcurrentHashMap</code>类型的成员变量attributes，保存所有属性，Spring的Root wac也放在这里。</p><p>配置wac：设置<code>contextId</code>等属性—&gt; 将sc设置到wac里—&gt;获取<code>web.xml</code>里的<code>contextConfigLocation</code>配置路径—&gt;初始化内容资源—&gt;扫描用户配置的<code>globalInitializerClasses</code>和<code>contextInitializerClasses</code>—&gt;初始化这些类—&gt;刷新<code>context</code>—&gt;设置Root wac的active、closed的值，进入到Spring Ioc容器的初始化。</p><p>在这里，Spring为了适应不同的Web容器打破双亲委派机制的情况，有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">   <span class="comment">//如果当前类的类加载器和当前线程的上下文加载器是一样的，则将context赋值给当前类全局变量</span></span><br><span class="line">   currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">//将上下文放入到map中</span></span><br><span class="line">   currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿Tomcat举例来说，Tomcat打破了JVM的双亲委派机制：</p><p><code>CommonClassLoader</code>：加载那些能在Web应用和Tomcat之间共享的类；</p><p><code>SharedClassLoader</code>：Web应用之间能够共享的类，比如Spring；</p><p><code>CatalinaClassLoader</code>：加载Tomcat自身需要的类；</p><p><code>WebAppClassLoader</code>：每一个Web应用都有自己的<code>WebAppClassLoader</code>，打破了双亲委派，它会首先从本地缓存查找是否加载过，然后再去使用父加载器去查找，如果没有接着会使用<code>ExtClassLoader</code>（也可以说会使用<code>BootstrapClassLoader</code>，避免Web应用的类覆盖JRE类），然后会在本地文件系统中查找，最后会交由系统类加载器（因为<strong>Class.forName默认使用的就是AppClassLoader</strong>）。</p><p>使用WebAppClassLoader加载的业务类可以通过<code>Thread.currentThread().getContextClassLoader()</code>来获得类加载器；</p><p>使用<code>ContextLoader.class.getClassLoader()</code>获得的是ContextLoader类加载器，如果两个类加载器是一致的，就可以将wac作为全局的静态变量<code>currentContext</code>的值，如果不是一致的，就需要用一个线程安全的<code>ConcurrentHashMap</code>来保存当前创建的wac，通过这种方式来保证线程间wac的私有。</p><h2 id="Servlet-WebApplication"><a href="#Servlet-WebApplication" class="headerlink" title="Servlet WebApplication"></a>Servlet WebApplication</h2><p>第二个Servlet WebApplication容器，是在<code>DispatcherServlet</code>初始化的过程中进行创建的。其实本质而言，这就是一个最正常的Servlet，和平时常见的的那种执行doGet，doPost的servlet没有任何区别，使用IDEA生成类图（<code>command+alt+u</code>）如下：</p><p><img src="/Spring-MVC源码初探/DispatcherServlet-Class-Diagram.png" alt></p><ul><li><code>HttpServletBean</code>：将<code>ServletConfig</code>设置到Servlet对象中</li><li><code>FrameworkServlet</code>：初始化ServletBean，创建Servlet wac</li><li><code>DispatcherServlet</code>：初始化Spring MVC中的九个组件</li></ul><h3 id="HttpServletBean"><a href="#HttpServletBean" class="headerlink" title="HttpServletBean"></a>HttpServletBean</h3><p>这个类实现了<code>EnvironmentCapable</code>, <code>EnvironmentAware</code>接口，通过Spring的*Aware这类接口的感知能力，将environment注入进来。</p><p>在init这个方法中遍历所有的<code>&lt;init-param&gt;</code>标签中配置的参数，封装成<code>PropertyValues</code>，实现类是继承了<code>MutablePropertyValues</code>的<code>ServletConfigPropertyValues</code>，并将当前的Servlet对象转化成一个<code>BeanWrapper</code>对象，同时将pvs放到这个bw里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">		<span class="comment">//解析web.xml中的init-param标签，封装到pvs中，这个构造函数中有一个所有initParams的遍历</span></span><br><span class="line">		PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">		<span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//将当前这个Servlet对象转化成一个BeanWrapper对象</span></span><br><span class="line">				BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">				ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">				<span class="comment">//注册自定义的属性编辑器，碰到Resource类型的属性，就会使用自定义的属性加载器进行处理</span></span><br><span class="line">				bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">				<span class="comment">//留给子类实现的初始化bw对象</span></span><br><span class="line">				initBeanWrapper(bw);</span><br><span class="line">				<span class="comment">//TODO Joy 将属性值pvs设置到bw里,需要好好研究一下是怎么将contextConfigLocation反射赋值到FrameworkServlet里的</span></span><br><span class="line">				bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">					logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">		<span class="comment">//交给FrameworkServlet来实现</span></span><br><span class="line">		initServletBean();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>在<code>ServletConfigPropertyValues</code>这个类的构造函数里，通过构造一个set集合来判断属性是否齐全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServletConfigPropertyValues</span><span class="params">(ServletConfig config, Set&lt;String&gt; requiredProperties)</span></span></span><br><span class="line"><span class="function">				<span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//将必须的配置转换成一个set集合，当web.xml中配置了一个，就从set中移除一个，直到所有缺失的都移除</span></span><br><span class="line">			Set&lt;String&gt; missingProps = (!CollectionUtils.isEmpty(requiredProperties) ?</span><br><span class="line">					<span class="keyword">new</span> HashSet&lt;&gt;(requiredProperties) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">			Enumeration&lt;String&gt; paramNames = config.getInitParameterNames();</span><br><span class="line">			<span class="keyword">while</span> (paramNames.hasMoreElements()) &#123;</span><br><span class="line">				String property = paramNames.nextElement();</span><br><span class="line">				Object value = config.getInitParameter(property);</span><br><span class="line">				addPropertyValue(<span class="keyword">new</span> PropertyValue(property, value));</span><br><span class="line">				<span class="keyword">if</span> (missingProps != <span class="keyword">null</span>) &#123;</span><br><span class="line">					missingProps.remove(property);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Fail if we are still missing properties.</span></span><br><span class="line">			<span class="keyword">if</span> (!CollectionUtils.isEmpty(missingProps)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(</span><br><span class="line">						<span class="string">"Initialization from ServletConfig for servlet '"</span> + config.getServletName() +</span><br><span class="line">						<span class="string">"' failed; the following required properties were missing: "</span> +</span><br><span class="line">						StringUtils.collectionToDelimitedString(missingProps, <span class="string">", "</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure><p>以上代码非常值得学习。</p><h3 id="FrameWork-Servlet"><a href="#FrameWork-Servlet" class="headerlink" title="FrameWork Servlet"></a>FrameWork Servlet</h3><p>该类中有一个非常重要的参数：WebApplicationContext。对于这个servlet wac的赋值，可以有四种方式：</p><ol><li><code>FrameWork Servlet</code>的构造函数</li><li>实现了<code>ApplicationContextAware</code>接口，可以使用Spring的注入从而调用<code>#setApplicationContext</code></li><li><code>#findWebApplicationContext</code>方法</li><li><code>#createWebApplicationContext</code>方法</li></ol><p>在父类<code>HttpServletBean</code>的<code>#init</code>方法里，最后一行就是调用本类中的<code>#initServletBean</code>方法，这个方法的重点是<code>#initWebApplicationContext</code>方法，而<code>#initFrameworkServlet</code>方法由于没有任何实现，所以暂时不管。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取ContextLoader初始化的 ROOT WebApplicationContext</span></span><br><span class="line">		WebApplicationContext rootContext =</span><br><span class="line">				WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">		<span class="comment">//这个是方法中用于操作的引用，避免直接操作全局变量</span></span><br><span class="line">		WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果此时不为空，可能来自于构造函数传入，或者Srping Aware接口注入</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">			wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">			<span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">				<span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">					<span class="comment">//还没有激活时，开始进行配置和刷新，configureAndRefreshWebApplicationContext中会注册独有的监听</span></span><br><span class="line">					<span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">					<span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">					<span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">						<span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">						cwac.setParent(rootContext);</span><br><span class="line">					&#125;</span><br><span class="line">					configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">			<span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">			<span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">			<span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">			<span class="comment">// 主动寻找wac，这种场景是因为用户自己在web.xml中定义了`ContextAttribute`，但是一般我们都不会配置</span></span><br><span class="line">			wac = findWebApplicationContext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">			<span class="comment">//最后会主动创建，并且执行configureAndRefreshWebApplicationContext</span></span><br><span class="line">			wac = createWebApplicationContext(rootContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这个参数参数表示是否已经接收到刷新，如果没有就要立即执行onRefresh</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">			<span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">			<span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">			<span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">			<span class="comment">//即使这个wac不是支持刷新的cac，或者在构造时已经刷新过，这里也要执行onRefresh</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">				<span class="comment">//最最最最核心的方法来了！！！九大组件～</span></span><br><span class="line">				onRefresh(wac);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将创建的servlet wac放到ServletContext中</span></span><br><span class="line">		<span class="comment">//每个servlet都有自己的ServletConfig，用当前类的类名+".CONTEXT."+servlet名字的方式</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">			<span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">			String attrName = getServletContextAttributeName();</span><br><span class="line">			getServletContext().setAttribute(attrName, wac);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> wac;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>过程比较复杂的是创建Servlet WebApplicationContext的过程，在<code>#createWebApplicationContext</code>这个方法里，还是采用的和Root wac一样的创建方式，也就是默认<code>XmlWebApplciationContext</code>的类型反射创建wac，然后设置父容器，设置contextConfigLocation参数，这个参数就是上一节中说过通过反射赋值到FrameworkServlet中的，随后在<code>#configureAndRefreshWebApplicationContext</code>方法中，设置了ServletContext，ServletConfig，NameSpace，基本和<code>ContextLoader</code>类里Root wac的创建方式类似。但是—这里随后又注册了一个<code>ApplicationEventListener</code>，简单提一下Spring中的事件机制：</p><ul><li>事件-<code>ApplicationEvent extends EventObject</code></li><li>发布方-<code>ApplicationEventPublisher</code></li><li>消费方-<code>ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener</code></li></ul><p>和容器相关的事件的又分为：</p><p><img src="/Spring-MVC源码初探/ApplicationContextEvent-and-Implementions.png" alt="ApplicationContextEvent-and-Implementions.png"></p><p>跟监听有关的类图如下：</p><p><img src="/Spring-MVC源码初探/SourceFilteringListener-Extends-Structure.png" alt="SourceFilteringListener-Extends-Structure.png"></p><p><code>#configureAndRefreshWebApplicationContext</code>注册了一个<code>SourceFilteringListener</code>，这个listener专门用来监听和传入的wac有关的事件，当产生容器刷新事件时，实际上是执行refresh方法以后，会发送对应的事件类型，这里就是<code>ContextRefreshedEvent</code>类型的事件，被<code>SourceFilteringListener</code>监听到以后，在<code>#onApplicationEvent</code>方法中判断事件源是否是传入的wac，如果是，交由代理<code>ContextRefreshListener</code>的实例去执行对应的<code>#onApplicationEvent</code>方法，而<code>ContextRefreshListener</code>实际上是<code>FrameworkServlet</code>的私有内部类，重写了<code>#onApplicationEvent</code>方法，那么这个方法的作用其实很简单—调用外部类FrameworkServlet的<strong>onRefresh方法，初始化9大组件。</strong></p><p>最后，将新创建的这个Servlet wac放到Servlet Context的attribute中。</p><p><strong>总结：</strong></p><ol><li><p>在FrameworkServlet中，如果Servlet wac还没有激活，就会去配置，并且执行Spring Ioc容器的刷新，然后监听事件，触发类中的onRefresh</p></li><li><p>如果Servlet wac没有找到或者为空，则执行创建，同样执行Spring Ioc的刷新，触发onRefresh</p></li><li>如果Servlet wac已经激活，需要判断是否已经收到过Ioc容器的容器刷新事件，如果没有，同样要触发onRefresh</li></ol><h3 id="Dispatcher-Servlet"><a href="#Dispatcher-Servlet" class="headerlink" title="Dispatcher Servlet"></a>Dispatcher Servlet</h3><p>这个类是核心调度类，但是其调用逻辑相对来说并不算复杂，只是代码量不小，其核心方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//文件上传解析器</span></span><br><span class="line">		initMultipartResolver(context);</span><br><span class="line">		<span class="comment">//本地化资源/国际化资源解析器</span></span><br><span class="line">		initLocaleResolver(context);</span><br><span class="line">		<span class="comment">//主题解析器：根据请求头判断使用PC主题还是移动主题</span></span><br><span class="line">		initThemeResolver(context);</span><br><span class="line">		<span class="comment">//uri映射解析器：根据uri匹配合适的handler</span></span><br><span class="line">		initHandlerMappings(context);</span><br><span class="line">		<span class="comment">//uri处理解析器：根据匹配到到的hadler处理请求</span></span><br><span class="line">		initHandlerAdapters(context);</span><br><span class="line">		<span class="comment">//异常解析器：根据请求处理异常请求</span></span><br><span class="line">		initHandlerExceptionResolvers(context);</span><br><span class="line">		<span class="comment">//请求到视图解析器：根据请求获得视图名</span></span><br><span class="line">		initRequestToViewNameTranslator(context);</span><br><span class="line">		<span class="comment">//最终视图解析器：视图最终解析</span></span><br><span class="line">		initViewResolvers(context);</span><br><span class="line">		<span class="comment">//FlashMap解析器：重定向参数临时保存</span></span><br><span class="line">		initFlashMapManager(context);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>另外配一幅网上找的图：</p><p><img src="/Spring-MVC源码初探/Spring-MVC-Request-Flow.jpg" alt="Spring-MVC-Request-Flow.jpg"></p><p>其具体的工作流程，留待后面请求处理详解里在细细梳理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，Spring MVC容器初始化部分的内容到此结束，下一节开始学习Spring MVC对于Servlet 3.0的支持、SPI机制、以及Spring Aware的动态感知。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>芋艿的源码解析博客：<a href="http://www.iocoder.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://www.iocoder.cn/</a></p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创、技术分享。请作者喝杯茶吧！</div><button id="rewardButton" disable="enable" onclick="var qr = document.getElementById(&quot;QR&quot;); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/wechatpay.png" alt="刘会俊 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.png" alt="刘会俊 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java/" rel="tag"># Java</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/浅记持续交付.html" rel="next" title="浅记持续交付"><i class="fa fa-chevron-left"></i> 浅记持续交付</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/Spring-MVC源码初探-二-Servlet-3-0、SPI、Aware.html" rel="prev" title="Spring MVC源码初探(二)-Servlet 3.0、SPI、Aware">Spring MVC源码初探(二)-Servlet 3.0、SPI、Aware <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="刘会俊"><p class="site-author-name" itemprop="name">刘会俊</p><p class="site-description motion-element" itemprop="description">热爱coding的指弹玩家</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/liuhuijun11832" title="GitHub &rarr; https://github.com/liuhuijun11832" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/qin-yuan-78-98/activities" title="知乎 &rarr; https://www.zhihu.com/people/qin-yuan-78-98/activities" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-globe"></i>知乎</a> </span><span class="links-of-author-item"><a href="http://www.guitar-coder.cn/img/Wechat.jpeg" title="微信 &rarr; http://www.guitar-coder.cn/img/Wechat.jpeg" rel="noopener" target="_blank"><i class="fa fa-fw fa-wechat"></i>微信</a> </span><span class="links-of-author-item"><a href="http://www.guitar-coder.cn/img/QQ.jpeg" title="qq &rarr; http://www.guitar-coder.cn/img/QQ.jpeg" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>qq</a> </span><span class="links-of-author-item"><a href="mailto:liuhuijun_2017@163.com" title="E-Mail &rarr; mailto:liuhuijun_2017@163.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.iocoder.cn/" title="http://www.iocoder.cn/" rel="external nofollow noopener noreferrer" target="_blank">芋道源码</a></li><li class="links-of-blogroll-item"><a href="http://blog.didispace.com/" title="http://blog.didispace.com/" rel="external nofollow noopener noreferrer" target="_blank">程序猿DD</a></li><li class="links-of-blogroll-item"><a href="https://blog.iooo.tech" title="https://blog.iooo.tech" rel="external nofollow noopener noreferrer" target="_blank">张砚池的博客</a></li><li class="links-of-blogroll-item"><a href="https://guanpengchn.github.io/" title="https://guanpengchn.github.io/" rel="external nofollow noopener noreferrer" target="_blank">牧码</a></li><li class="links-of-blogroll-item"><a href="https://suveng.github.io/blog" title="https://suveng.github.io/blog" rel="external nofollow noopener noreferrer" target="_blank">suveng`s blog</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#准备工作"><span class="nav-number">1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#容器"><span class="nav-number">2.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Root-WebApplication"><span class="nav-number">2.1.</span> <span class="nav-text">Root WebApplication</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet-WebApplication"><span class="nav-number">2.2.</span> <span class="nav-text">Servlet WebApplication</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HttpServletBean"><span class="nav-number">2.2.1.</span> <span class="nav-text">HttpServletBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FrameWork-Servlet"><span class="nav-number">2.2.2.</span> <span class="nav-text">FrameWork Servlet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatcher-Servlet"><span class="nav-number">2.2.3.</span> <span class="nav-text">Dispatcher Servlet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">京ICP备19003464号 </a>&copy; 2018 – <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">刘会俊</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">480k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">7:17</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">NexT.Mist</a></div><span class="post-meta-divider">| </span><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>function createtime(){var n=new Date("01/31/2019 10:16:43");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest.min.js"></script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/src/utils.js?v=7.0.0"></script><script src="/js/src/motion.js?v=7.0.0"></script><script src="/js/src/schemes/muse.js?v=7.0.0"></script><script src="/js/src/scrollspy.js?v=7.0.0"></script><script src="/js/src/post-details.js?v=7.0.0"></script><script src="/js/src/bootstrap.js?v=7.0.0"></script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=7.0.0"></script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(e,t){var n=$("<div>").addClass("highlight-wrap");$(t).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(e){var t=$(this).parent().find(".code").find(".line").map(function(e,t){return $(t).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=document.createRange(),a=window.getSelection(),i=window.pageYOffset||document.documentElement.scrollTop;n.style.top=i+"px",n.style.position="absolute",n.style.opacity="0",n.value=t,n.textContent=t,n.contentEditable=!0,n.readOnly=!1,document.body.appendChild(n),o.selectNode(n),a.removeAllRanges(),a.addRange(o),n.setSelectionRange(0,t.length);var d=document.execCommand("copy");d?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(e){var t=$(this).find(".copy-btn");setTimeout(function(){t.text("复制")},300)}).append(t)})</script></body></html><!-- rebuild by neat -->