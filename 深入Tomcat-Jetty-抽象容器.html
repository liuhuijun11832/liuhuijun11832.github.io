<!-- build time:Sun Jan 12 2020 22:39:43 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script>!function(e,t,o,c,i,d,a){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,d=t.createElement(o),a=t.getElementsByTagName(o)[0],d.async=1,d.src=c,d.charset="utf-8",a.parentNode.insertBefore(d,a)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/37dd6385.js","daovoice"),daovoice("init",{app_id:"37dd6385"}),daovoice("update")</script><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0"><link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222"><script>!function(e,t,o,c,i,d,a){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,d=t.createElement(o),a=t.getElementsByTagName(o)[0],d.async=1,d.src=c,d.charset="utf-8",a.parentNode.insertBefore(d,a)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/37dd6385.js","daovoice"),daovoice("init",{app_id:"37dd6385"}),daovoice("update")</script><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"7.0.0",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"Z2W38WTNSC",apiKey:"7df7d53c7892e2ae907462c4158eca2d",indexName:"hexo-blog",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="深入学习Tomca和Jetty"><meta name="keywords" content="Tomcat,Jetty"><meta property="og:type" content="article"><meta property="og:title" content="深入Tomcat&#x2F;Jetty(五)-抽象容器"><meta property="og:url" content="http://blog.guitar-coder.cn/深入Tomcat-Jetty-抽象容器.html"><meta property="og:site_name" content="guitar-coder"><meta property="og:description" content="深入学习Tomca和Jetty"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://blog.guitar-coder.cn/深入Tomcat-Jetty-抽象容器/JDK-ClassLoader.png"><meta property="og:image" content="http://blog.guitar-coder.cn/深入Tomcat-Jetty-抽象容器/Tomcat-ClassLoader.png"><meta property="og:updated_time" content="2020-01-01T14:46:37.813Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="深入Tomcat&#x2F;Jetty(五)-抽象容器"><meta name="twitter:description" content="深入学习Tomca和Jetty"><meta name="twitter:image" content="http://blog.guitar-coder.cn/深入Tomcat-Jetty-抽象容器/JDK-ClassLoader.png"><link rel="canonical" href="http://blog.guitar-coder.cn/深入Tomcat-Jetty-抽象容器.html"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>深入Tomcat/Jetty(五)-抽象容器 | guitar-coder</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c91d856e0af2969135bf34fb87ae8d93";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">guitar-coder</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="menu-item-icon fa fa-fw fa-comments"></i><br>留言板</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.guitar-coder.cn/深入Tomcat-Jetty-抽象容器.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘会俊"><meta itemprop="description" content="热爱coding的指弹玩家"><meta itemprop="image" content="/images/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="guitar-coder"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">深入Tomcat/Jetty(五)-抽象容器</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-19 14:51:31" itemprop="dateCreated datePublished" datetime="2019-07-19T14:51:31+08:00">2019-07-19</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-01-01 22:46:37" itemprop="dateModified" datetime="2020-01-01T22:46:37+08:00">2020-01-01</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数： <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">12k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">11 分钟</span></div><div class="post-description">深入学习Tomca和Jetty</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Tomcat-Host容器"><a href="#Tomcat-Host容器" class="headerlink" title="Tomcat-Host容器"></a>Tomcat-Host容器</h1><p>热加载：后台线程定期检测类的变化，如果有变化，就重新加载类，不会清空session；</p><p>热部署：后台线程定时检测应用的变化，如果有变化，就会清空session；</p><p>线程池：ScheduledThreadPoolExecutor，周期性执行</p><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec.scheduleWithFixedDelay(</span><br><span class="line">              <span class="keyword">new</span> ContainerBackgroundProcessor(),<span class="comment">// 要执行的 Runnable</span></span><br><span class="line">              backgroundProcessorDelay, <span class="comment">// 第一次执行延迟多久</span></span><br><span class="line">              backgroundProcessorDelay, <span class="comment">// 之后每次执行间隔多久</span></span><br><span class="line">              TimeUnit.SECONDS);        <span class="comment">// 时间单位`</span></span><br></pre></td></tr></table></figure><p><code>ContainerBackgroundProcessor</code>，<code>ContainerBase</code>内部类，实现<code>Runnable</code>接口；</p><p>执行当前容器里的<code>backgroundProcess()</code>，并且递归调用子容器的<code>backgroundProcess()</code>，如果子容器的backgroundProcessorDelay大于0，表明子容器有自己的线程，所以此时就不用父类来调用；</p><p>这个方法是接口中的默认方法，所以顶层engine启动后台线程以后，它会启动顶层engine以及子engine的周期性任务。</p><p>由于ContainerBase是所有组件基类，所以其他组件都可以由自己的周期性任务。</p><a id="more"></a><h2 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h2><p>通过context的backgroundProcess实现：</p><ul><li>webapploader检查WEB-INF/classes和WEB-INF/lib下目录的类文件有没有变化；</li><li>sessionManager检查是否有过期session；</li><li>WebResources检查静态资源是否有变化。</li></ul><p>webapploader的工作：</p><ul><li>停止和销毁context以及wrapper；</li><li>停止和销毁关联的filter和listener；</li><li>停止和销毁关联的pipline-value；</li><li>停止和销毁类加载器，和相关的类文件资源；</li><li>启动context，并重新生成前四步销毁的资源。</li></ul><p><strong>默认情况下，Tomcat的热加载功能是关闭的，需要配置<code>&lt;Context reloadable=&quot;true&quot;/&gt;</code>来启用</strong>。</p><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p>通过Host容器实现，Host通过监听HostConfig实现，HostConfig就是前文”周期性事件“的监听器。</p><ul><li>检查web应用目录是否被删除，如果被删除了就把相应的Context容器销毁；</li><li>如果有新的War包，就部署相应的应用。</li></ul><p>宏观webapps目录级别，而不是web应用目录下文件的变化。</p><h1 id="Servlet管理"><a href="#Servlet管理" class="headerlink" title="Servlet管理"></a>Servlet管理</h1><p>Wrapper：核心：变量<code>Field Servlet</code>，方法<code>Method loadServlet</code>用来创建servlet并初始化（Servlet规范要求）。</p><p>执行时期：延迟加载，用到时才会加载该Servlet，除非在web.xml里设置了loadOnStartUp=true，但是Wrapper会在Tomcat启动时就会被创建。</p><p>机制：Pipeline-Valve链，每一个容器都有一个BasicValve，Wrapper的BasicValve为StandardWrapperValve。</p><p>步骤：</p><ol><li>创建Servlet实例；</li><li>给当前请求创建一个Filter链；</li><li>调用这个Filter链，链中的最后一个Filter会调用Servlet。</li></ol><h1 id="Filter管理"><a href="#Filter管理" class="headerlink" title="Filter管理"></a>Filter管理</h1><p>可以在web.xml里配置，所以Filter的实例是在Context容器中管理的，本质上是用一个HashMap来保存Filter。</p><p>Filter生命周期很短，是和每次请求对应的，请求结束这个Filter链就结束了。</p><p>核心：ApplicationFilterChain，每个链包含了末尾的链所要调用的Servlet。</p><p>最后会调用servlet的service方法。</p><p>本质上和Pipeline-Valve都是一样的责任链模式，但是它的实现方式是：<strong>FilterChain有doFilter方法，并且每一个Filter首先调用FilterChain的doFilter方法，由于Filter链中会保存当前Filter所在的位置，这样就会调用下一个Filter的doFilter方法，形成了一个链式调用。</strong></p><h1 id="Listener管理"><a href="#Listener管理" class="headerlink" title="Listener管理"></a>Listener管理</h1><p>可以在web.xml里配置，所以Listener也是在Context容器中管理的。Listener可以监听容器内生命状态的变化（比如Context容器的启动和停止，Session的创建和销毁），或者Context、Session的某个属性变了或者新的请求来了等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听属性值变化的监听器,每个请求的属性可能不一样，所以要保证线程安全，并且写多读少</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; applicationEventListenersList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听生命事件的监听器，Context容器的启动和停止是能保证线程安全，所以这里直接用数组</span></span><br><span class="line"><span class="keyword">private</span> Object applicationLifecycleListenersObjects[] = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>Tomcat定义了ServletContextListener接口作为第三方扩展，在启动的时候遍历所有该类型的监听器触发事件，Spring就是实现了这个接口，监听Context的启停事件，和LifecycleListener不同的是，LifecycleListener定义在生命周期管理组件中，由基类LifecycleBase统一管理。</p><h1 id="异步Servlet"><a href="#异步Servlet" class="headerlink" title="异步Servlet"></a>异步Servlet</h1><p>用法：<code>@WebServlet(urlPatterns = {&quot;/async&quot;}, asyncSupported = true)</code>；</p><p>异步默认超时时长：30s；</p><p>原理：req.startAsync和ctx.complete，前者创建一个异步上下文AsyncContext对象，用来保存request和response等上下文信息；</p><p>CoyoteAdapter：flush数据把响应发回浏览器；如果是异步请求，就设置一个异步标志为truel，并在随后的ProtocolHandler判断该标志，如果是一个异步请求，那么它会把当前的Socket的协议处理者Processor缓存起来，将SocketWrapper对象响应的Processor存到一个Map数据结构里。</p><p>ctx.complete：调用request的action方法，通知连接器这个请求处理完了—-&gt;传入操作码processSocketEvent—-&gt;processSocket—-&gt;创建SocketProcess任务类—-&gt;交给Tomcat线程池处理。</p><p>适合场景：I/O密集型业务。</p><h1 id="内嵌式的Tomcat"><a href="#内嵌式的Tomcat" class="headerlink" title="内嵌式的Tomcat"></a>内嵌式的Tomcat</h1><p>以Spring Boot为例，它抽象了WebServer接口，提供给Tomcat和Jetty去实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> WebServerException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时还提供了ServletWebServerFactory来创建容器，即返回WebServer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletWebServerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">WebServer <span class="title">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>ServletContextInitializer</code>就是ServletContext的初始化器，并且在getWebServer方法中会调用onStartUp方法，所以如果想在Servlet容器中注册自己的Servlet，可以实现该接口。</p><p>WebServletFactoryCutomizerBeanPostProcessor：这是一个BeanPostProcessor，在postProcessBeforeInitialization过程中寻找WebServerFactoryCustomizer类型的Bean，并依次调用WebServerFactoryCustomizer接口的customize方法做一些定制化。</p><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>Spring核心：ApplicationContext；</p><p>抽象类：AbstractApplicationContext；</p><p>方法：refresh()或者onRefresh()；</p><p>原理：ServletWebServerApplicationContext重写了onRefresh方法创建内嵌式Web容器；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebServer <span class="title">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 实例化一个 Tomcat，可以理解为 Server 组件。</span></span><br><span class="line">    Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 创建一个临时目录</span></span><br><span class="line">    File baseDir = <span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span> ? <span class="keyword">this</span>.baseDirectory : <span class="keyword">this</span>.createTempDir(<span class="string">"tomcat"</span>);</span><br><span class="line">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 初始化各种组件</span></span><br><span class="line">    Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">    tomcat.getService().addConnector(connector);</span><br><span class="line">    <span class="keyword">this</span>.customizeConnector(connector);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">    tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.configureEngine(tomcat.getEngine());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 创建定制版的 "Context" 组件。</span></span><br><span class="line">    <span class="keyword">this</span>.prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册Servlet的方式"><a href="#注册Servlet的方式" class="headerlink" title="注册Servlet的方式"></a>注册Servlet的方式</h2><h3 id="注解式"><a href="#注解式" class="headerlink" title="注解式"></a>注解式</h3><p>Spring Boot 的配置类需要开启@ServletComponentScan用于扫描@WebServlet、@WebFilter、@WebListener等。</p><h3 id="Java-Config"><a href="#Java-Config" class="headerlink" title="Java Config"></a>Java Config</h3><p>在Spring的配置类中加入Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">servletRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> HelloServlet(),<span class="string">"/hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>实现前文提到的上下文初始化类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletRegister</span> <span class="keyword">implements</span> <span class="title">ServletContextInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//Servlet 3.0 规范新的 API，动态注册新的Servlet</span></span><br><span class="line">        ServletRegistration myServlet = servletContext</span><br><span class="line">                .addServlet(<span class="string">"HelloServlet"</span>, HelloServlet.class);</span><br><span class="line">                </span><br><span class="line">        myServlet.addMapping(<span class="string">"/hello"</span>);</span><br><span class="line">        </span><br><span class="line">        myServlet.setInitParameter(<span class="string">"name"</span>, <span class="string">"Hello Servlet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意的是，其实ServletRegistrationBean也是通过实现ServletContextInitializer来实现的，会交给Spring来管理。而ServletContainerInitializer的实现类是被Tomcat管理的。</p></blockquote><h2 id="Web容器定制"><a href="#Web容器定制" class="headerlink" title="Web容器定制"></a>Web容器定制</h2><p>在Spring Boot 2.0中，可以通过两种方式定制Web容器：</p><ul><li>通过Web容器工程ConfigurableServletWebServerFactory来定制参数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGeneralCustomizer</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">  <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        factory.setPort(<span class="number">8081</span>);</span><br><span class="line">        factory.setContextPath(<span class="string">"/hello"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过特定web容器的工厂，比如TomcatServletWebServerFactory来进一步定制：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTomcatCustomizer</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">TomcatServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(TomcatServletWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        factory.setPort(<span class="number">8081</span>);</span><br><span class="line">        factory.setContextPath(<span class="string">"/hello"</span>);</span><br><span class="line">        factory.addEngineValves(<span class="keyword">new</span> TraceValve() );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现追踪分布式项目中的路径</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceValve</span> <span class="keyword">extends</span> <span class="title">ValveBase</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        request.getCoyoteRequest().getMimeHeaders().</span><br><span class="line">        addValue(<span class="string">"traceid"</span>).setString(<span class="string">"1234xxxxabcd"</span>);</span><br><span class="line"></span><br><span class="line">        Valve next = getNext();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == next) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next.invoke(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Jetty-HandlerWrapper"><a href="#Jetty-HandlerWrapper" class="headerlink" title="Jetty-HandlerWrapper"></a>Jetty-HandlerWrapper</h1><p>Jetty通过HndlerWrapper实现责任链。</p><p><code>WebAppContext</code> -&gt; <code>SessionHandler</code> -&gt;<code>SecurityHandler</code> -&gt;<code>ServletHandler</code>。</p><p>核心：<code>protected Handler _handler</code>，持有下一个Hadnler的引用，并且会在handle方法里执行下一个Handler。</p><p>ScopeHandler：核心Handler，被间接或者直接地继承，<code>_handler</code>是持有的下一个Handler的引用，并且会在handler方法里调用下一个Handler；</p><ul><li><code>_outerScope</code>：根据它是否为null来判断使用<code>doScope()</code>还是<code>doHandler()</code>，头节点肯定为null，其他节点的该字段肯定指向Handler链中头节点，言下之意—如果是头节点，就执行doScope，如不是头节点，执行doHandler；</li><li><code>__outerScope</code>：使用<code>ThreadLocal&lt;ScopeHandler&gt;</code>进行包装，在需要时取出赋值给<code>_outerScope</code>，由于一般不能在上下文作为参数传递，所以这里作为线程私有变量；</li><li><code>_nextScope</code>：表示下一个<code>ScopeHandler</code>，和<code>_handler</code>区别在于，<code>_handler</code>的下一位可能是Wrapperx，而<code>_nextScope</code>表示下一个必须是<code>ScopeHandler</code>。</li></ul><p>通过这几个参数，保证让ScopeHandler链上的doScope方法在doHandle、handle方法之前执行，并且保证不同ScopeHandler的doScope都是按照它在链上的先后顺序执行。</p><p>ContextHandler：ScopeHandler的子类，类似于Tomcat中的Context组件，对应一个Web应用，功能是给Servlet的执行维护一个上下文环境，并且将请求转发到相应的Servlet，doHandler里做了请求的修正，类加载器设置，以及调用nextScope。</p><h1 id="Spring框架中的设计模式"><a href="#Spring框架中的设计模式" class="headerlink" title="Spring框架中的设计模式"></a>Spring框架中的设计模式</h1><p>简单工厂：<code>interface BeanFactory</code>，使用方式：<code>beanFatory.get(&quot;userService&quot;)</code>；</p><p>工厂方法：<code>interface FactoryBean</code>，使用方式：定义一个类<code>UserFactory</code>实现<code>FactoryBean</code>，那<code>UserFactory</code>所产生的实例就都是User了；</p><p>单例模式：<code>private final Map&lt;String,Object&gt; singletonObjects = new ConcurrentHashMap&lt;String,Object&gt;;</code>先到HashMap中获取对象，如果没有拿到，则通过<code>Class.forName(String)</code>反射创建一个实例并添加到<code>singletonObjects</code>里。</p><p>代理模式：</p><ul><li>抽象接口：代理角色和被代理角色都要实现该接口；</li><li>目标对象：被代理的对象，用于实现业务；</li><li>代理对象：内部含有对目标对象的引用，在执行目标对象的前后执行一部分逻辑。</li></ul><p>静态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">IStudentDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class StudentDao implements <span class="title">IStudentDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"保存成功"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class StudentDaoProxy implements <span class="title">IStudentDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> IStudentDao target;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StudentDaoProxy</span><span class="params">(IStudentDao target)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.pritln(<span class="string">"我增强了某某某"</span>);</span><br><span class="line">		target.save();</span><br><span class="line">		System.out.pritln(<span class="string">"增强结束了"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Aop采用的是动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理对象不是自己生成，而是由InvocationHandler生成和管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始事务"</span>);</span><br><span class="line">        Object result = method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">"结束事务"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IStudentDao stuDao = <span class="keyword">new</span> StudentDao();</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(stuDao);</span><br><span class="line">        IStudentDao studentDao = (IStudentDao) Proxy.newProxyInstance(stuDao.getClass().getClassLoader(), stuDao.getClass().getInterfaces(), handler);</span><br><span class="line">        studentDao.save();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring Aop有两种代理方式：JDK（<code>JdkDynamicAopProxy implements InvocationHandler</code>）；Cglib（<code>CglibAopProxy</code>）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JDK <span class="number">8</span></span><br><span class="line">class Proxy:</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams =</span><br><span class="line">        &#123; InvocationHandler.class &#125;;</span><br><span class="line"><span class="comment">//newProxyInstance：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="comment">//通过ProxyClassFactory调用ProxyGenerator生成了代理类</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    <span class="comment">//找到参数为InvocationHandler.class的构造函数</span></span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">    <span class="comment">//创建代理类实例</span></span><br><span class="line">    <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在ProxyGenerator类中：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String name,Class&lt;?&gt;[] interfaces, <span class="keyword">int</span> accessFlags))&#123;&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;&#125;</span><br><span class="line"><span class="comment">//根据接口生成实现类的字节码文件</span></span><br></pre></td></tr></table></figure><p>而Cglib使用的是字节码拼接，不依赖接口，更强大更灵活。</p><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>概念：将.class文件加载到JVM<strong>方法区</strong>，并在<strong>堆区</strong>创建一个java.lang.Class的对象实例 ，作为具体业务类对象实例。</p><p>时期：需要用到时才加载。</p><p>Java实现：<code>abstract class：ClassLoader</code>，包含<code>private final ClassLoader parent</code>、<code>public loadClass(String name)</code>，<code>protected findClass(String name)</code>。</p><p>步骤：</p><p>如果父加载器不为空，委托给父加载器加载（递归），否则查找bootstrap加载器是否加载过，最后才会调用自己的<code>findClass</code>方法。</p><p>findClass：从本地文件系统或者网络中寻找.class文件读入到内存；将读入内存的字节数组转成Class对象。</p><!--more--><p>JDK类加载器:</p><p><img src="/深入Tomcat-Jetty-抽象容器/JDK-ClassLoader.png" alt="JDK-ClassLoader.png"></p><ul><li>BootstrapClassLoader:启动类加载器，由C语言实现，加载rt.jar，resources.jar等；</li><li>ExtClassLoader:扩展类加载器，加载jre\lib\ext目录下的jar；</li><li>AppClassLoader:系统类加载器，加载classpath下的类，也是默认的应用程序类加载器。</li><li>自定义：用于加载自定义自定义路径下的类。</li></ul><p>这种指向不是继承关系，而是parent指向了另一个ClassLoader，所以如果想打破双亲委派的话，只需要新写一个ClassLoader继承ClassLoader类再重写loadClass和findClass。</p><h1 id="Tomcat类加载器"><a href="#Tomcat类加载器" class="headerlink" title="Tomcat类加载器"></a>Tomcat类加载器</h1><p>结构：</p><p><img src="/深入Tomcat-Jetty-抽象容器/Tomcat-ClassLoader.png" alt="Tomcat-ClassLoader.png"></p><p>CommonClassLoader：加载那些能在Web应用和Tomcat之间共享的类；</p><p>SharedClassLoader：Web应用之间能够共享的类，比如Spring；</p><p>CatalinaClassLoader：加载Tomcat自身需要的类；</p><p>WebAppClassLoader：每一个Web应用都有自己的WebAppClassLoader，打破了双亲委派，它会首先从本地缓存查找是否加载过，然后再去使用父加载器去查找，如果没有接着会使用ExtClassLoader（也可以说会使用BootstrapClassLoader，避免Web应用的类覆盖JRE类），然后会在本地文件系统中查找，最后会交由系统类加载器（因为Class.forName默认使用的就是AppClassLoader）。</p><blockquote><p>Spring 加载也是通过Class.forName的方式加载的，并且Spring加载Bean也是用的加载Spring的类加载器。</p></blockquote><p><em>通常Spring是用SharedClassLoader来加载，但是业务类又应该使用WebAppClassLoader来加载，所以Tomcat在启动的时候会设置线程上下文加载器，Spring在启动时可以通过<code>Thrad.currentThread().getContextClassLoader()</code>来获取类加载器来加载业务类。</em></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>第三方Jar包加载特定Web应用的类，可以通过线程上下文加载器来实现；</li><li>每个WEB应用自己的Java类文件和JAR包，分别放在WEB-INF/lib和WEB-INF/classes目录中；</li><li>多个WEB应用共享类，放在Web容器指定的共享目录下。</li></ul></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创、技术分享。请作者喝杯茶吧！</div><button id="rewardButton" disable="enable" onclick="var qr = document.getElementById(&quot;QR&quot;); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}"><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/wechatpay.png" alt="刘会俊 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.png" alt="刘会俊 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Jetty/" rel="tag"># Jetty</a> <a href="/tags/Tomcat/" rel="tag"># Tomcat</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/深入Tomcat-Jetty-内核知识和高性能之道.html" rel="next" title="深入Tomcat/Jetty(四)-零拷贝与高性能"><i class="fa fa-chevron-left"></i> 深入Tomcat/Jetty(四)-零拷贝与高性能</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/深入Tomcat-Jetty-通用组件.html" rel="prev" title="深入Tomcat/Jetty(六)-通用组件">深入Tomcat/Jetty(六)-通用组件 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="刘会俊"><p class="site-author-name" itemprop="name">刘会俊</p><p class="site-description motion-element" itemprop="description">热爱coding的指弹玩家</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">5</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">28</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/liuhuijun11832" title="GitHub &rarr; https://github.com/liuhuijun11832" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/qin-yuan-78-98/activities" title="知乎 &rarr; https://www.zhihu.com/people/qin-yuan-78-98/activities" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-globe"></i>知乎</a> </span><span class="links-of-author-item"><a href="http://www.guitar-coder.cn/img/Wechat.jpeg" title="微信 &rarr; http://www.guitar-coder.cn/img/Wechat.jpeg" rel="noopener" target="_blank"><i class="fa fa-fw fa-wechat"></i>微信</a> </span><span class="links-of-author-item"><a href="http://www.guitar-coder.cn/img/QQ.jpeg" title="qq &rarr; http://www.guitar-coder.cn/img/QQ.jpeg" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>qq</a> </span><span class="links-of-author-item"><a href="mailto:liuhuijun_2017@163.com" title="E-Mail &rarr; mailto:liuhuijun_2017@163.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.iocoder.cn/" title="http://www.iocoder.cn/" rel="external nofollow noopener noreferrer" target="_blank">芋道源码</a></li><li class="links-of-blogroll-item"><a href="http://blog.didispace.com/" title="http://blog.didispace.com/" rel="external nofollow noopener noreferrer" target="_blank">程序猿DD</a></li><li class="links-of-blogroll-item"><a href="https://blog.iooo.tech" title="https://blog.iooo.tech" rel="external nofollow noopener noreferrer" target="_blank">张砚池的博客</a></li><li class="links-of-blogroll-item"><a href="https://guanpengchn.github.io/" title="https://guanpengchn.github.io/" rel="external nofollow noopener noreferrer" target="_blank">牧码</a></li><li class="links-of-blogroll-item"><a href="https://suveng.github.io/blog" title="https://suveng.github.io/blog" rel="external nofollow noopener noreferrer" target="_blank">suveng`s blog</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Tomcat-Host容器"><span class="nav-number">1.</span> <span class="nav-text">Tomcat-Host容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#热加载"><span class="nav-number">1.1.</span> <span class="nav-text">热加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#热部署"><span class="nav-number">1.2.</span> <span class="nav-text">热部署</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet管理"><span class="nav-number">2.</span> <span class="nav-text">Servlet管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Filter管理"><span class="nav-number">3.</span> <span class="nav-text">Filter管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Listener管理"><span class="nav-number">4.</span> <span class="nav-text">Listener管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异步Servlet"><span class="nav-number">5.</span> <span class="nav-text">异步Servlet</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内嵌式的Tomcat"><span class="nav-number">6.</span> <span class="nav-text">内嵌式的Tomcat</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#启动过程"><span class="nav-number">6.1.</span> <span class="nav-text">启动过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注册Servlet的方式"><span class="nav-number">6.2.</span> <span class="nav-text">注册Servlet的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注解式"><span class="nav-number">6.2.1.</span> <span class="nav-text">注解式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Config"><span class="nav-number">6.2.2.</span> <span class="nav-text">Java Config</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态注册"><span class="nav-number">6.2.3.</span> <span class="nav-text">动态注册</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web容器定制"><span class="nav-number">6.3.</span> <span class="nav-text">Web容器定制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Jetty-HandlerWrapper"><span class="nav-number">7.</span> <span class="nav-text">Jetty-HandlerWrapper</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring框架中的设计模式"><span class="nav-number">8.</span> <span class="nav-text">Spring框架中的设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类加载"><span class="nav-number">9.</span> <span class="nav-text">类加载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tomcat类加载器"><span class="nav-number">10.</span> <span class="nav-text">Tomcat类加载器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">京ICP备19003464号 </a>&copy; 2018 – <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">刘会俊</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">480k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">7:17</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> 强力驱动</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">NexT.Mist</a></div><span class="post-meta-divider">| </span><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>function createtime(){var n=new Date("01/31/2019 10:16:43");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest.min.js"></script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/src/utils.js?v=7.0.0"></script><script src="/js/src/motion.js?v=7.0.0"></script><script src="/js/src/schemes/muse.js?v=7.0.0"></script><script src="/js/src/scrollspy.js?v=7.0.0"></script><script src="/js/src/post-details.js?v=7.0.0"></script><script src="/js/src/bootstrap.js?v=7.0.0"></script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=7.0.0"></script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(e,t){var n=$("<div>").addClass("highlight-wrap");$(t).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(e){var t=$(this).parent().find(".code").find(".line").map(function(e,t){return $(t).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=document.createRange(),a=window.getSelection(),i=window.pageYOffset||document.documentElement.scrollTop;n.style.top=i+"px",n.style.position="absolute",n.style.opacity="0",n.value=t,n.textContent=t,n.contentEditable=!0,n.readOnly=!1,document.body.appendChild(n),o.selectNode(n),a.removeAllRanges(),a.addRange(o),n.setSelectionRange(0,t.length);var d=document.execCommand("copy");d?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(e){var t=$(this).find(".copy-btn");setTimeout(function(){t.text("复制")},300)}).append(t)})</script></body></html><!-- rebuild by neat -->